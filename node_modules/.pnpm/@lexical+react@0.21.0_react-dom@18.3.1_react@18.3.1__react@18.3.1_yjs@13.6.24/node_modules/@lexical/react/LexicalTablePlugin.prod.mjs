/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{useLexicalComposerContext as e}from"@lexical/react/LexicalComposerContext";import{setScrollableTablesActive as t,TableNode as r,TableCellNode as o,TableRowNode as n,INSERT_TABLE_COMMAND as l,$createTableNodeWithDimensions as s,$computeTableMapSkipCellCheck as a,$createTableCellNode as i,$getTableAndElementByKey as c,$getNodeTriplet as d,$computeTableMap as f,$isTableRowNode as u,$isTableCellNode as p,getTableElement as m,applyTableHandlers as g}from"@lexical/table";import{mergeRegister as h,$insertNodeToNearestRoot as C,$insertFirst as v}from"@lexical/utils";import{$isTextNode as x,COMMAND_PRIORITY_EDITOR as S,$createParagraphNode as w}from"lexical";import{useEffect as b}from"react";function N(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var L=N((function(e){const t=new URLSearchParams;t.append("code",e);for(let e=1;e<arguments.length;e++)t.append("v",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));function M({hasCellMerge:N=!0,hasCellBackgroundColor:M=!0,hasTabHandler:R=!0,hasHorizontalScroll:k=!1}){const[T]=e();return b((()=>{t(T,k)}),[T,k]),b((()=>(T.hasNodes([r,o,n])||L(10),h(T.registerCommand(l,(({columns:e,rows:t,includeHeaders:r})=>{const o=s(Number(t),Number(e),r);C(o);const n=o.getFirstDescendant();return x(n)&&n.select(),!0}),S),T.registerNodeTransform(r,(e=>{const[t]=a(e,null,null),r=t.reduce(((e,t)=>Math.max(e,t.length)),0),o=e.getChildren();for(let e=0;e<t.length;++e){const n=o[e];if(!n)continue;const l=t[e].reduce(((e,t)=>t?1+e:e),0);if(l!==r)for(let e=l;e<r;++e){const e=i(0);e.append(w()),n.append(e)}}}))))),[T]),b((()=>{const e=new Map,t=(t,r,o)=>{const n=m(t,o),l=g(t,n,T,R);e.set(r,[l,n])},o=T.registerMutationListener(r,(r=>{T.getEditorState().read((()=>{for(const[o,n]of r){const r=e.get(o);if("created"===n||"updated"===n){const{tableNode:n,tableElement:l}=c(o);void 0===r?t(n,o,l):l!==r[1]&&(r[0].removeListeners(),e.delete(o),t(n,o,l))}else"destroyed"===n&&void 0!==r&&(r[0].removeListeners(),e.delete(o))}}),{editor:T})}),{skipInitialization:!1});return()=>{o();for(const[,[t]]of e)t.removeListeners()}}),[T,R]),b((()=>{if(!N)return T.registerNodeTransform(o,(e=>{if(e.getColSpan()>1||e.getRowSpan()>1){const[,,t]=d(e),[r]=f(t,e,e),o=r.length,n=r[0].length;let l=t.getFirstChild();u(l)||L(175);const s=[];for(let e=0;e<o;e++){0!==e&&(l=l.getNextSibling(),u(l)||L(175));let t=null;for(let o=0;o<n;o++){const n=r[e][o],a=n.cell;if(n.startRow===e&&n.startColumn===o)t=a,s.push(a);else if(a.getColSpan()>1||a.getRowSpan()>1){p(a)||L(176);const e=i(a.__headerState);null!==t?t.insertAfter(e):v(l,e)}}}for(const e of s)e.setColSpan(1),e.setRowSpan(1)}}))}),[T,N]),b((()=>{if(!M)return T.registerNodeTransform(o,(e=>{null!==e.getBackgroundColor()&&e.setBackgroundColor(null)}))}),[T,M,N]),null}export{M as TablePlugin};
